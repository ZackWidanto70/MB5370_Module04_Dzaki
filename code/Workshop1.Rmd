---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Ben Cresswell"
output: html_document
date: "2024-03-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Install and load tidyverse packages
```{r}
## install.packages("tidyverse") # Delete this line once installed
library("tidyverse")
```


# Load the data (mpg is built into ggplot2)
```{r}
data(mpg)
```


# Quick data checks
```{r}
head(mpg)
glimpse(mpg)
summary(mpg)
```


# Create first plot
```{r}
ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))
```

The plot shows a negative relationship between engine size (displ) and fuel efficiency (hwy). In other words, cars with big engines use more fuel. What does this say about fuel efficiency and engine size?



# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?
```{r}
ggplot() 
# Or with just the data specified?
ggplot(data = mpg)
```

We need to map some aesthetics!!

# When you’re creating a plot, you essentially need two attributes of a plot: a geom and aesthetics.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```


# Change point colour by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```

# Change point size by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```
Note the warning!!!
<using size for a discrete variable is not advised>

# Change transparency (alpha) by class
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```
Another warning!!
Question: When would using alpha (or size be appropriate??)
alpha --> transparency!
Use it for overlapping data points (make transparency useful)

# Change point shape by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```
Shape automatically only sign 6 shapes. but our data has seven. Therefore we need to assign manually

# Make all points blue
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = displ <5))
```
This code shows logical value categories on displ
when displ value < 5, it becomes TRUE (conditional)!


# Troubleshooting 
```{r}
ggplot(data = mpg) +  # the + should be at the end of the line!!!!!!
geom_point(mapping = aes(x = displ, y = hwy))
```



# Faceting

## facet_wrap
<use facet_wrap on single variable and/or discrete data>
Split the plot out by car type (class)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```


## facet_grid
A separate facet for each combination of drive-type (e.g. 4WD) * number of cylinders
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```
Note that there are no occurrences of 5 cylinder 4WDs OR RWD vehicles!


## facet_grid by just row (or column)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  #facet_grid(cyl ~ .)
  facet_grid(. ~ cyl) # Alternatively

```
If we use cyl ~ ., the cyl class becomes the row separator
if we use . ~ cyl, the cyl class becomes the column separator


# Exercise:
Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  #facet_grid(cyl ~ .)
  facet_wrap(~ cyl, nrow = 2) # Alternatively
```
in facet_wrap, nrow makes the plot according to x row
ncol makes the plot according to x column

# Lines
We already used points:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displx, y = hwy))
```


However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```
### Question: whey don't we use geom_line() here? What would that look like? ###
```{r}
ggplot(data = mpg) + 
  geom_line(mapping = aes(x = displ, y = hwy))
```
We dont use geom_line because line connects from one single data to another, making it look ugly
Whilst smooth you basically make a continuous line with standard error

So let’s recap. A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didn’t. 

## Using comments (#)
```{r}
ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy)) + # points horrible 
  geom_smooth(mapping = aes(x = displ, y = hwy)) # try smooth line
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.

# Changing linetype
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) # Can also use "lty = " for the same result
```


# Grouping

Group objects by categorical variable!
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
```
 
# Change line colour based on drv value
```{r}
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  )
```

# Multiple geoms
We already did this one way
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```
However, stating the mapping, x =, and y =, everytime geom_ function appears is not efficient

A better way...
We state the mapping, aes(x =, y =) in the front. So anything we add geom_ for, 
already tracked using the x and y
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```


# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Now we have different colours to indicate the raw data (geom_point) and one colour for the overall relationship (geom_smooth). Neat!


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
 #use data = filter to only plot the class subcompact
```

Question: what does the "se = FALSE" do?
To not plot the standard error


# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

The code result is just the same. However, the former has efficiency!

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))

```


3.  Will these two graphs look different? Why/why not?

same as number 2
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```


# Transformations and stats

## Load data
```{r}
data("diamonds")
glimpse(diamonds)
str(diamonds)
```

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut)) #bar is barplot --> categorical data!

ggplot(data = diamonds) + 
  stat_count (mapping = aes(x = cut)) #stat_count is the same as geom_bar for categorical/count data!
```

# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
) #we are basically making a new dataframe
#From the summary of the old ones
# Here, we simply make "cut" frequency

demo
```


```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")

# Why cant we make the plot without stat = identity?
# does the identity makes category Ideal in the middle?
```
### Question: Why did we specify now specify a y axis?
Because here is a dataframe. in Demo, cut is tied with freq


# What if we want to know the proportion rather than the absolute frequency?
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))
# here, after)_stat(prop) is to create statistics data of proportion!!!
# cut = class/categorical
# so y is a statistical data of cut frequency
```

Question: does anyone get the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.
If so, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

# Plotting statistical details
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min, #to create min value of depth (y) per cut (x)
        fun.max = max, # to create max value of depth per cut
    fun = median #to plot the meadian value of depth
  )
```


# Aesthetic adjustments 
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut)) # colour = outline!
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut)) # fill = entire plot!
```
Question: Does anyone notice anything different in the colour scheme of this plot?
(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)

## UNANSWERED YET!

Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```


# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```
# using position = "identity"
place each object exactly where it falls in the context of the graph.


# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity") #bad graph, ended up increase complexity
```

# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```


# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.

Because position --> Fill (like in a picture, fill it until covers the y scale, 1.00 or 100%)

Therefore, position = "fill" automatically makes the data proportion!!
Only can be used for *double categorical* data!
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
# y-axis ended up being proportion!
```


# position = "dodge" 
Places overlapping objects directly beside one another.
beside = horizontally!
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point **to avoid overplotting when points overlap**. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  #geom_point(mapping = aes(x = displ, y = hwy))

# this is the rough one. We should use this.
# Points would be inaccurate because they were moved slightly from their original values
# but used to prevent overlap between points.

ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  geom_point(mapping = aes(x = displ, y = hwy))

# this is corrected and makes aesthetically beautiful
```
# Grammar for Graphics

ggplot(data = <DATA>) +  # THIS IS GLOBAL
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>), # THIS IS LOCAL
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <FACET_FUNCTION>

Remember to pick waht would be inherited aesthetics (aes) from global to local 


# WORKSHOP 2 

## 2.1. Labels

### 2.1.1. Title
```{r}
ggplot(mpg, aes(displ, hwy)) +  #data mpg, x displ, y hwy
    geom_point(aes(color = class)) + #colors based on class
     geom_smooth(se = FALSE) + #make line plot without interval Standard error
      labs(title = "Fuel effeciency generally decreases with engine size")
```
### 2.1.2. Subtitle
Add more details with **smaller font** beneath title
*caption*: adds text at **bottom right** of plot
```{r}
ggplot(mpg, aes(displ, hwy)) +  #data mpg, x displ, y hwy
    geom_point(aes(color = class)) + #colors based on class
     geom_smooth(se = FALSE) + #make line plot without interval Standard error
      labs(
        title = "Fuel effeciency generally decreases with engine size",
        subtitle = "Two seaters (sports cars) are an exception because of their light weight",
        caption = "Data from fueleconomy.gov"
)
```
### 2.1.3. Axis and Legend labels

```{r}
ggplot(mpg, aes(displ, hwy)) +  #data mpg, x displ, y hwy
    geom_point(aes(color = class)) + #colors based on class
     geom_smooth(se = FALSE) + #make line plot without interval Standard error
      labs(
        x = "Engine Displacement (L)",
        y = "Highway fuel economy (mpg)",
        colour = "Car Type" #Legend
)
```


## 2.2. Annotations
**adding the text into the plot!! Horayy!**

use geom_text()!
If texts overlap --> use nudge() but from different package!
```{r}
best_in_class <- mpg %>% # from data mpg
  group_by(class) %>% # Search from each class
  filter(row_number(desc(hwy)) == 1) # desc = descending order
# this function basically searches the max number of hwy (kilometer distance per 1 gallon fuel)
# in each class
# use descending order because it sorts from the biggest (Max) to min
# descending order with number 1 = biggest (max)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class) #labels overlap
# here, the name shows the model (car type) 
```


## 2.3. Scales
Scales is what the axis number shows

### 2.3.1. normal default scale
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```
### 2.3.2. Edited scales
to edit, you must use vector **c(min_value, max_value)** 

can also use scale_x_continuous()
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous(limits = c(20,30)) +
  scale_colour_discrete() # this is to change colour in the scale?

```

## 2.4. Axis Ticks

### 2.4.1. Breaks
Breaks is basically showing the sequential ticks in the x/y axis scale
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
# here, we start to make interval of y-axis by 5 from 15 to 40
# Other than this, the ticks wont be shown! (look at 0 to 10 not being shown!)
```


## 2.5. Legends and colour schemes

a. Change position of legend. The **default** legend position is right!
b. Make plot as wide as possible
c. Hide them
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) #make the plot into a variable

base + theme(legend.position = "left")  #Setup the legend position
```
```{r}
base + theme(legend.position = "top")  #Setup the legend position
base + theme(legend.position = "top", legend.byrow = TRUE)  #Sort the legend by alphabetical
```
```{r No legend}
base + theme(legend.position = "none")  #Setup the legend position
```

## 2.6. Replacing a scale

## 2.6.1. Scale function replacement
We can edit the scale from just real number into functions such as log or exp
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() # Very ugly. 
```
Now, we try to changeit into log scale
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```
### 2.6.2. Colour scale change - Palette
Palette: http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) # class is drv

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1") # set1 is one of the color palette format in R

## REDUNDANT SHAPE MAPPING
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) + # here, not only the colour scale change, but we also change the shape
  scale_colour_brewer(palette = "Set1")

```
### 2.6.3. Colour scale change - Manual
use scale_colour_manual
```{r}
presidential %>% #Default data with column name, start, end, party
  mutate(id = 33 + row_number()) %>% #creates a new column, id, with 33 + row number
  # Thats why id of Eisenhower is 34, because 33 + row (1)
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
```
1. Here, id means President number .....
2. geom_segment is creating the line for each point
with xend = end, is the endpoint of the line based on the end date column
whilst yend = id is per each presidents id (only singular number, no range!)

3. **plot aim**: Showing the relative scale of each president how long their era were

4. Another colour scale is using viridis!
### 2.6.4. Package viridis and hexbin
use scale_colour_viridis()
```{r}
#install.packages('viridis')
#install.packages('hexbin')
library(viridis)
p <- ggplot(mtcars, aes(wt, mpg))
p + geom_point(size = 4, aes(colour = factor(cyl))) +
    scale_color_viridis(discrete = TRUE) +
    theme_bw()
```
```{r}
df <- tibble( # note we're just making a fake dataset so we can plot it
  x = rnorm(10000),
  y = rnorm(10000)
)
ggplot(df, aes(x, y)) +
  geom_hex() + # a new geom!
  coord_fixed()

ggplot(df, aes(x, y)) +
  geom_hex() +
  viridis::scale_fill_viridis() +
  coord_fixed()


```


## 2.7. Themes
To change **non-data** elements!!! (Layout, background, etc.)
### 2.7.1. Theme Black and White
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()
```

### 2.7.2. Theme Light
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light() #No bold borderline!
```

### 2.7.3. Theme classic
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic() #without grids!
```

### 2.7.4. Theme dark
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark() #Grey background

```
### 2.7.5. Theme FORMAT
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
    theme (panel.border = element_blank(), #No borderline shading 
        panel.grid.minor.x = element_blank(), #No minor grid in x axis
        panel.grid.minor.y = element_blank(), # No minor grid in y axis
        legend.position="bottom", # Place legend in bottom
        legend.title=element_blank(), # No legend title
        legend.text=element_text(size=8), # Set up the font size of legend
        panel.grid.major = element_blank(), # No major grid in the graph!
        legend.key = element_blank(), 
        legend.background = element_blank(), # No legend background colour
        axis.text.y=element_text(colour="black"), # set up font colour x
        axis.text.x=element_text(colour="black"), # set up font colour y
        text=element_text(family="Arial"))  # set up font type

```


## 2.8. Saving and exporting your plots

export using ggsave()
HOWEVER, make sure your working directory is set right!
```{r}
#getwd()
ggplot(mpg, aes(displ, hwy)) + geom_point()

ggsave("my-plot1.jpg")
#> Saving 7 x 4.32 in image
```
# Assignment Number 1

from journal: https://www.frontiersin.org/journals/marine-science/articles/10.3389/fmars.2020.00001/full
**Figure 3**

```{r Homework Number 1}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(viridis)
df <- read.csv("Homework1_Data.csv", header = TRUE, sep = ";")
tibble(df)

ggplot(data= df, mapping = aes(x = Species, y = Contribution)) +
  geom_boxplot(aes(fill = Source))+
  labs(
    title = "Proportion of organic sources on seagrass soil organic carbon",
    subtitle = "results of isotope mixing model",
    x = "seagrass meadow species",
    y = "Contribution of sources to soil organic carbon (%)",
    fill = "Source of organic carbon"
  )+
  scale_fill_viridis(discrete = TRUE) +
    theme_classic()+
  theme(legend.position = "top",
        legend.justification = "top",
        legend.direction = "horizontal",
        legend.byrow = FALSE)+
  scale_y_continuous(breaks = seq(0, 100, by = 10), limits = c(0,100))+
  scale_x_discrete(guide = guide_axis(n.dodge = 2))

ggsave("Homework 1 Assignment.jpg",
       width = 7,
       height = 5,
       units = "in"
       )
```
# Workshop 3

## 3.1. Tidyr

### 3.1.1. Making a tidy data
The **tidy format**:
Variables in Vertical (column).
Observations in horizontal (row).
Values in each cell!

**PRO TIP**: Always use tibble(df) to see if your data is tidy!

```{r Showing tidy data}
#library(tidyverse)
table1 # This data is tidy!
table2
table3
```
### 3.1.2. Pipe coding
pipe (%>% or |>) is executing multiple functions within the same variable
kinda like this:
My intended output: ABCD
A |> add (B) |> add (C) |> add (D)

```{r Using pipe feature (%>%)}
# Compute rate per 10,000
table1 %>% 
  mutate(rate = cases / population * 10000) # Mutate adds new column

# Compute cases per year
table1 %>% 
  count(year, wt = cases) # does not add new column but instead get a new tibble

# Visualise changes over time
#library(ggplot2)
ggplot(table1, aes(year, cases)) + 
  geom_point(aes(colour = country)) +
  geom_line(aes(group = country), colour = "grey50") 
  
```
### 3.1.2. Exercises (UNFINISHED)
```{r}
# Number TB cases per country per year
table2 %>%
  count(year, type, wt = count)
# Matching population per country per year
table2 %>%
  count(country, year, wt = count)


```
## 3.2. Pivoting dataset

Most of the data that we would process will be untidy.
Especially, when:
a. one variable spread across multiple columns
b. One observation spread across multiple rows

Solution: **pivot** to lengthen or widen the data!!!

### 3.2.1. Pivot - Lengthening
```{r}
billboard # The data is still wide, contains wk1 - wk76
```
Here, each observation (row) is dedicated for song (track)
The columns (wk1-wk76) describe variables of the song!
However, the column contains two meaning!
a. variable (week)
b. values (rank, number)

Therefore, we should separate the variable week with the value rank into individual columns!
### 3.2.2. Pivoting process
```{r data lengthening - pivot}
billboard |>
  pivot_longer(
    cols = starts_with("wk"), # cols: columns to pivot into longer format, becomes ROWS and variable
    names_to = "week", # Character vector, change the name; naming the header of new column in cols
    values_to = "rank" # specifying the name of column to create from the data stored in cell values
    # keeping the values (rank numnber) identic to each cols (week) of observation (track)
  )
  
billboard |>
  pivot_longer(
    cols = !c(artist, track, date.entered), # same as starts_with
    # this is more useful if the column names are very different
    names_to = "week", 
    values_to = "rank" 
  )
```
When we pivot the column names, the column that does not have values **automatically turns into NA**.
(example: 2 Pac Baby dont cry wk8 - wk10)
### 3.2.3. Pivoting with clearing NAs

```{r data lengthening - Pivot with NA clean (step 0)}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE # this line is to delete rows with NA!
  )
# Results will be fewer rows compared to the previous.
```
### 3.2.4. Pivoting longer

Examine how pivot does to our data
```{r Pivot lengthening examination}

# create a tiblbe
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)
df

# pivoting
# to make bp1 and bp2 as new column, whilst creating one observation = one row!
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
```
### 3.2.5. Widening datasets
```{r}
# Example data
cms_patient_experience # Already tidy!

# Examine unique values in measure_cd and measure_title
cms_patient_experience |> 
  distinct(measure_cd, measure_title)

# Data pivot - Widening
cms_patient_experience |> 
  pivot_wider(
    names_from = measure_cd, # widen the measure_cd 
    values_from = prf_rate # make separate columns for different values (prf_rate) of observations (measure_cd)
  )
# Still not complete. The org_... variables are still multiple in observation (rows)

cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
# Now each org_.. has individual values,
#and the variable measure_cd is widthened into CAHPS_GRP_x variables
# with the values from prf_rate
```
### 3.2.6 Widening Longer
Examine how pivot_wider does to our data
```{r}

df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)
df
df |> 
  pivot_wider(
    names_from = measurement,
    values_from = value
  )

df |> 
  distinct(measurement) |> 
  pull()

df |> 
  select(-measurement, -value) |> 
  distinct()

# What pivot_wider() does in a nutshell
df |> 
  select(-measurement, -value) |> 
  distinct() |> 
  mutate(x = NA, y = NA, z = NA)



```
To start pivoting process, pivot_wider() needs to figure out:
a. Column names --> Unique values in measurement (example)
b. Rows --> from column that will not be changed, aka id (example)

### 3.2.7. Pivot - Exercise 1

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(1,2,1,2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks

stocks %>% 
  pivot_wider(
    names_from = year,
    values_from = return) %>% # This one works, it widens the tibble
  pivot_longer(cols = `2015`:`2016`, names_to = "year", values_to = "return")

# Then, we fix the data type with
stocks %>% 
  pivot_wider(
    names_from = year,
    values_from = return) %>% # This one works, it widens the tibble
  pivot_longer(`2015`:`2016`,
    names_to = "year", 
    names_transform = list(year = as.numeric),
    values_to = "return")
  
   
```
Here, we see that in the first stocks tibble,
year (dbl), half(dbl), return(dbl)

Then, when we pivot_wider and pivot_longer, the final result is
half(dbl), year(chr), return(dbl)

See that the year becomes character. This is because when we pivot_wider, 2015 and 2016
in the column name becomes character!
Then when we pivot_longer to return it back as a variable (column), it stores it as character.
Same as the billboard tibble week! (it turns into character column).

### 3.2.8. Exercise 2
Why this code fails?
```{r}
table4a %>% 
  pivot_longer(
    c(1999, 2000),
    names_to = "year", 
    values_to = "cases")
# Change into
table4a %>% 
  pivot_longer(
    c("1999", "2000"), # Declare the column names as characters
    names_to = "year",
     names_transform = list(year = as.numeric),
    values_to = "cases")
# Now, the data is tidy!
```
Here, the declaration is not correct.
remember, as a column name, 1999 and 2000 are characters!
therefore, we need to declare them as characters not numbers.

### 3.2.9. Exercise 3
3.	Consider the sample tibble below. Do you need to make it wider or longer? What are the variables?
```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
preg
# Need to lengthen pivot!
preg %>%
  pivot_longer(
    cols = contains("male"),
    names_to = "gender",
    values_to = "count"
  )

```
## 3.3. Separating and uniting data tables in tibble

### 3.3.1. Separate()
Example using table3
```{r}
table3 %>%
  separate(rate, into = c("cases", "population"))
# separate() in default, separates a value when it detects non-number or letter character!
table3 %>%
  separate(rate, into = c("cases", "population"), sep = "/") # same!
# Separate can also detect numbers. We just need to declare if the separated values
# needs to be the natural type (for example, number will be converted into double!)
table3 %>%
  separate(rate, into = c("cases", "population"), sep = "/", convert = TRUE) 
# convert = T is to make cases and population values double (their natural type)

# Other type of separation, based on number of characters!
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```
### Unite()
```{r}
table5 %>% 
  unite(new, century, year, sep = "")
# Make a new column "new"
# Then, unite century and year
# with separators "" (none), so it concancenate together!
```

## 3.4. Handling Missing Values

### 3.4.1. Explicit missing value - NA
NA is stated!
```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
) 
treatment |>
  fill(everything())
# last observation carried forward, aka last available values is being copied to the next NA rows
```
### 3.4.2. Explicit missing value - Fixed Value
if its form of fixed value (e.g.: -99 or -9999)

```{r}
x <- c(1, 4, 5, 7, NA)
coalesce(x, 0)  # Change NA to 0
#> [1] 1 4 5 7 0

x <- c(1, 4, 5, 7, -99)
na_if(x, -99)  # Conditional, change the stated fixed value into NA
#> [1]  1  4  5  7 NA

# To register NA for N/A data

# students <- read_csv("data/students.csv", na = c("N/A", ""))

read_csv("a,b\n1,2,3\n4,5,6")
read_csv("a,b,c\n1,2\n1,2,3,4")
read_csv("a,b\n\"1")
read_csv("a,b\n1,2\na,b")
read_csv("a;b\n1;3")


```
### 3.4.3. Explicit missing value - NaN (Not a Number)
typically behaves **same as NaN**

```{r}
x <- c(NA, NaN)
x * 10
#> [1]  NA NaN
x == 1
#> [1] NA NA
is.na(x)
#> [1] TRUE TRUE
```
### 3.4.4. Implicit missing data
```{r}
stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
# missing data:
# a. price in year 2020 qtr 4
# b. completely unwritten, year 2021 qtr 1

stocks |>
  pivot_wider(
    names_from = qtr, 
    values_from = price
  ) # The missing year 2021 qtr 1 is shown


```
## 3.5. Relational Data
Simply put, joining dataframes together!

Main package: dplyr.

3 families of relational data:
a. Mutating joins = add new variables to one dataframe from matching observations
b. filtering joins = filter observations from one data frame based on whether
or not they match an observation in the other table
c. Set operation = treat observations as if they are set elements

### 3.5.1. Joining Datasets
Join datasets by identifying the **keys**.

**Keys**: A variable/set of variables that uniquely identifies an observation.
in SC5502, keys are the data ID (unique per observation, only 1!)

if the keys are the unique, main identity of a dataframe --> **primary**
if the keys are unique, but NOT main identity of dataframe --> **foreign**
```{r}
library(nycflights13)

airlines # First data
airports # second data
planes # third data. Primary key is tailnum
flights # Fourth data, THE MAIN DATA (COMPLETE).
# in Flights, tailnum is unique identity but only Foreign key
```
### 3.5.2. Identifying primary keys in datasets
filter n>1 result is not visible (because the variables only have 1 observation each!)

if data does not have primary key --> create one by mutate!!!

Primary key and corresponding foreign key forms relation!
```{r}
planes %>% 
  count(tailnum) %>% 
  filter(n > 1)  #tailnum is the primary key

weather %>% 
  count(year, month, day, hour, origin) %>% 
  filter(n > 1) 
weather |>
  count(origin) |>
  filter(n>1)

# Data that does not have primary key
flights %>% 
  count(year, month, day, flight) %>% 
  filter(n > 1) # Still has results, mainly n =2 or n = 3. NO clear unique identity

flights %>% 
  count(year, month, day, tailnum) %>% 
  filter(n > 1)
```
### 3.5.3. Mutating Joins
Combine variables from two tables.
adds to the **right side** of the data!!! Matches by row (observation) and corresponding keys!

```{r}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)

airlines # has 2 variables: carrier, name

# flights2 >< airlines via key CARRIER

flights2 %>%
  select(-origin, -dest) %>%  # drop down origin and dest
  left_join(airlines, by = "carrier") # the flights2 data is joined to the left side of airlines

# A way more complicated version
flights2 %>%
  select(-origin, -dest) %>% 
  mutate(name = airlines$name[match(carrier, airlines$carrier)])
```
### 3.5.4. Inner join
```{r Visual of Inner join}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
x %>% 
  inner_join(y, by = "key") # deleted 3 and 4 in key


```

### 3.5.5. Outer join
left_join() --> keep observation in x
right_join() --> keep all observations in y
full_join() --> keep all observations in x and y

All inexistent data will be considered as NA

### 3.5.6. Join with duplicate keys (non-unique)
```{r duplicate keys}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
left_join(x, y, by = "key") # create duplicates of 2 and 1, fits all
```
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)
left_join(x, y, by = "key") # make duplicates in x (x2 and x3)

      # Default, by = NULL - Joins all!
flights2 %>%  # year:hour, origin, dest, tailnum, carrier
  left_join(weather) # weather: origin, year:hour, temp, ...
# output: year:hour, origin, dest, tailnum, carrier, temp, ...
# here the keys are year:hour, origin.

      # Join by character vector
flights2 %>% # year:hour, origin, dest, tailnum, carrier
  left_join(planes, by = "tailnum") # tailnum, year, type, ...
# results: year.x, month:hour, origin, dest, TAILNUM, carrier, year.y

# Here, year in flights2 and tailnum means different!
# It separate the variables (columns)

      # join by NAMED character vector by = c("a" = "b")
# Match variable a in table x to variable b in table y

flights2 %>% # year:hour, origin, dest, tailnum, carrier
  left_join(airports, c("dest" = "faa")) # faa, name, lat, lon, ....
# output: year:hour, origin, dest, tailnum, carrier, name, lat, lon
# here, the faa in airports is considered the merging key of dest!

flights2 %>% 
  left_join(airports, c("origin" = "faa"))

```


# Assignment 2
```{r Data wrangling}
df1 <- read_csv("../data/export.csv") #If we worked in a project, we can do it like this
# Messy header

# Editing the header of main data
df2 <- df1 %>% 
  row_to_names(row_number = 1) %>%
  clean_names()


# Extracting the main data into several variables

diving <- df2 |>
  select(na | contains("diving")) |> # We are now selecting header with the name na and contains word "diving"
  row_to_names(row_number = 1) 
tibble(diving) #Still characters!

diving <- diving |> # Make the values in row number 1, into the header of columns!
  mutate(across(is.character, as.numeric)) |> # make all columns from character into doubles!
  # Mutate also forces the text N/A into NA
  filter(!is.na(CalendarYear)) |> # Filter out the NA from CalendarYear
  mutate(Type = "Diving")
tibble(diving)

line <- df2 |>
  select(na | contains("line")) |> # We are now selecting header with the name na and contains word "diving"
  row_to_names(row_number = 1) |>
  mutate(across(is.character, as.numeric)) |> # make all columns from character into doubles!
  # Mutate also forces the text N/A into NA
  filter(!is.na(CalendarYear)) |>
  mutate(Type = "Line")
tibble(line)

data = bind_cols(diving, line)
view(data)
```

```{r Data plotting}


```